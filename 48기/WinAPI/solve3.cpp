//버젼 정보
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 헤더파일 써주자 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
#include <windows.h>			//윈도우 헤더파일을 인크루드


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 전역변수 써주는 곳 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
HINSTANCE	g_hInst;						//전역 인스턴스의 핸들선언
HWND		g_hWnd;							//윈도우의 핸들


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 함수의 프로토 타입 써주는 곳 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
LRESULT CALLBACK WndProc(HWND,UINT,WPARAM,LPARAM);


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 윈도우 메인 함수 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance
		  ,LPSTR lpszCmdParam, int nCmdShow)
{
	MSG			Message;					//메세지 구조체 선언
	WNDCLASS	WndClass;					//윈도우 클래스 선언
	char  		szClassName[128] = "Seth";	//클래스 이름
	char  		szWinName[128] = "Seth";	//윈도우 이름



	g_hInst =	hInstance;		//인스턴스를 얻는다

	WndClass.cbClsExtra		= 0;									//여분메모리	
	WndClass.cbWndExtra		= 0;									//여분메모리
	WndClass.hbrBackground	= (HBRUSH)GetStockObject(WHITE_BRUSH);	//배경색상 지정
	WndClass.hCursor		= LoadCursor(NULL,IDC_ARROW);			//커서를 읽는다
	WndClass.hIcon			= LoadIcon(NULL,IDI_APPLICATION);		//아이콘을 읽는다
	WndClass.hInstance		= hInstance;							//윈도우 클래스의 인스턴스
	WndClass.lpfnWndProc	= (WNDPROC)WndProc;						//윈도우 프로시저의 이름
	WndClass.lpszClassName	= szClassName;							//윈도우 클래스의 이름
	WndClass.lpszMenuName	= NULL;									//메뉴의 이름
	WndClass.style			= CS_HREDRAW | CS_VREDRAW;				//윈도우의 스타일
	RegisterClass(&WndClass);										//클래스를 등록한다

	//윈도우를 만든다
	g_hWnd = CreateWindow(szClassName, szWinName, WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, 1024, 768,
		NULL, (HMENU)NULL, hInstance, NULL);
	ShowWindow(g_hWnd, nCmdShow);
	
	/*
	while(true)
	{
        /// 메시지큐에 메시지가 있으면 메시지 처리
		if( PeekMessage( &Message, NULL, 0U, 0U, PM_REMOVE ) )
		{
			if(Message.message == WM_QUIT) break;
			TranslateMessage( &Message );
			DispatchMessage( &Message );
		}
		else
		{
			test();

		}
		/// 처리할 메시지가 없으면 Render()함수 호출
		//	Render();
	}*/

	//메세지 루프
	while(GetMessage(&Message,0,0,0))
	{
		TranslateMessage(&Message);
		DispatchMessage(&Message);
	}
	return Message.wParam;
}


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 윈도우 프로시저 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
LRESULT CALLBACK WndProc(HWND hWnd,UINT iMessage,WPARAM wParam,LPARAM lParam)
{
	PAINTSTRUCT			ps;
	HDC					hdc;
	char				szBuf[128] = "";
	static int			nNumber = 0;

	static const int	nAsciiValue = 0x20;

	switch(iMessage)
	{
		case WM_PAINT:
			hdc = BeginPaint(hWnd, &ps);
			EndPaint(hWnd, &ps);
		break;
		case WM_LBUTTONDOWN:
			::InvalidateRect(g_hWnd, NULL, true);
			break;
		case WM_CHAR:
			if (nNumber >= 127)
				break;

			hdc = ::GetDC(g_hWnd);

			nNumber++;

			szBuf[nNumber] = wParam;

			if(szBuf[nNumber] >= 'A' && szBuf[nNumber] <= 'Z')
				szBuf[nNumber] = szBuf[nNumber] + nAsciiValue;
			else if(szBuf[nNumber] >= 'a' && szBuf[nNumber] <= 'z')
				szBuf[nNumber] = szBuf[nNumber] - nAsciiValue;				
			
			if (nNumber <= 64)
				::TextOut(hdc, 100 + nNumber*10, 100, &szBuf[nNumber], 1);
			else
				::TextOut(hdc, 100 + nNumber*10 - 64*10, 100 + 30, &szBuf[nNumber], 1);

			::InvalidateRect(g_hWnd, NULL, false);
			::ReleaseDC(g_hWnd,hdc);
		break;
		case WM_DESTROY:
			PostQuitMessage(0);
		return 0;
	}
	return(DefWindowProc(hWnd,iMessage,wParam,lParam));
}


//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
// ☆━─ 03-03-21, 참고사항들 seth. ─━☆
//━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━